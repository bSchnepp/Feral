Kernel is asked to run a non-native program:
	- If the same arch, then defer to libos and handler. All non-system programs are "non-native", so not the CPU emulator's problem (unless asked to do something later, ie, a console emulator.)
	
	- Otherwise, the program is loaded via an emulator. Which one depends on the target program (for example, generic Linux Aarch64 isn't going to run under the same emulator as XNU/Darwin Aarch64)
		- The emulator is woken up, told that this binary was expected to be run, and can branch from here after being invoked by kernel:
			- Ignore the request if it wants (ie, the emulator doesn't support it)
			- Proclaim that it wants to statically recompile specific sections of the binary (which the emulator defines), and then be given exclusive control of the relevant pages (VERY SLOW startup)
			- JIT compile target architecture, and allocate/reallocate pools of memory based upon what the emulator wants. The performance advantage over usermode emulation is that the kernel
			  doesn't have to bouce around a lot since it loads from a file and then recompiles *then* returns to usermode already in pages which can be used for execution. (JIT is done by kernel)
			 	(we are avoiding syscalls. This *really* hurts performance. Avoid syscalls as much as we can. Once we're in kernel mode, avoid going out, and vice versa, until we have nothing else to do.)
			 
		- Emulators need a certain SDK (exported by this library), and to be dynamically linked to a loader library.
