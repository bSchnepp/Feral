/*
Copyright (c) 2018, 2019, 2020 Brian Schnepp

Permission is hereby granted, free of charge, to any person or organization 
obtaining  a copy of the software and accompanying documentation covered by 
this license (the "Software") to use, reproduce, display, distribute, execute, 
and transmit the Software, and to prepare derivative works of the Software, 
and to permit third-parties to whom the Software is furnished to do so, all 
subject to the following:

The copyright notices in the Software and this entire statement, including 
the above license grant, this restriction and the following disclaimer, must 
be included in all copies of the Software, in whole or in part, and all 
derivative works of the Software, unless such copies or derivative works are 
solely in the form of machine-executable object code generated by a source 
language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY 
DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.
 */

#ifndef _FERAL_PROC_ELF_H_
#define _FERAL_PROC_ELF_H_

#include <feral/stdtypes.h>


#define PT_NULL (0x00)
#define PT_LOAD (0x01)
#define PT_DYNAMIC (0x02)
#define PT_INTERP (0x03)
#define PT_NOTE (0x04)
#define PT_SHLIB (0x05)
#define PT_PHDR (0x06)

#define PT_LOOS (0x60000000)
#define PT_HIOS (0x6FFFFFFF)
#define PT_LOPROC (0x70000000)
#define PT_HIPROC (0x7FFFFFFF)

#define SHT_NULL (0x00)
#define SHT_PROGBITS (0x01)
#define SHT_SYMTAB (0x02)
#define SHT_STRTAB (0x03)
#define SHT_RELA (0x04)
#define SHT_HASH (0x05)
#define SHT_DYNAMIC (0x06)
#define SHT_NOTE (0x07)
#define SHT_NOBITS (0x08)
#define SHT_REL (0x09)
#define SHT_SHLIB (0x0A)
#define SHT_DYNSYM (0x0B)

#define SHT_INIT_ARRAY (0x0E)
#define SHT_FINI_ARRAY (0x0F)

#define SHT_PREINIT_ARRAY (0x10)
#define SHT_GROUP (0x11)
#define SHT_SYMTAB_SHNDX (0x12)

#define SHT_SHT_LOOS (0x60000000)

#define SHF_WRITE (0x001)
#define SHF_ALLOC (0x002)
#define SHF_EXECINSTR (0x004)
#define SHF_MERGE (0x010)
#define SHF_STRINGS (0x020)
#define SHF_INFO_LINK (0x040)
#define SHF_LINK_ORDER (0x080)
#define SHF_OS_NONCONFIRMING (0x100)
#define SHF_GROUP (0x200)
#define SHF_TLS (0x400)

#define SHF_MASKOS (0x0FF00000)
#define SHF_MASKPROC (0xF0000000)
#define SHF_ORDERED (0x40000000)
#define SHF_EXCLUDE (0x80000000)

#define MACHINE_ID_NONE (0x0000)
#define MACHINE_ID_SPARC (0x0002)
#define MACHINE_ID_X86 (0x0003)
#define MACHINE_ID_MIPS (0x0008)
#define MACHINE_ID_POWER (0x0014)
#define MACHINE_ID_S390 (0x0016)
#define MACHINE_ID_AARCH32 (0x0028)
#define MACHINE_ID_JCORE (0x002A)
#define MACHINE_ID_IA64 (0x0032)
#define MACHINE_ID_X86_64 (0x003E)
#define MACHINE_ID_AARCH64 (0x00B7)
#define MACHINE_ID_RISCV (0x00F3)

typedef enum
{
	ELF_ARCH_NONE = 0x00,
	ELF_ARCH_SPARC = 0x02,
	ELF_ARCH_I386 = 0x03,
	ELF_ARCH_MIPS = 0x08,
	ELF_ARCH_POWER = 0x14,
	ELF_ARCH_AARCH32 = 0x28,
	ELF_ARCH_JCORE = 0x2A,
	ELF_ARCH_IA64 = 0x32,
	ELF_ARCH_X86_64 = 0x3E,
	ELF_ARCH_AARCH64 = 0xB7,
} ElfFormatArchitecture;

typedef enum
{
	ELF_SYSTEM_V = 0x00,

	ELF_NETBSD = 0x02,
	ELF_LINUX = 0x03,
	ELF_GNU = 0x04,
	ELF_INDIANA = 0x06,


	ELF_FREEBSD = 0x09,


	ELF_FERAL_WAYPOINT = 0xFE,
} ElfFormatIdentifier;

typedef enum
{
	ELF_RELOCATABLE = 0,
	ELF_EXECUTABLE = 1,
	ELF_SHARED = 2,
	ELF_CORE = 3
} ElfExecTypes;

/* Do we need pragma pack(1)?? */

typedef struct ElfHeader64
{
	CHAR magic[4];
	UINT8 cpu_bitsz;
	UINT8 cpu_endian;
	UINT8 elf_version;
	UINT8 e_identifier;
	UINT64 e_padding;
	UINT16 e_type;
	UINT16 e_machine;
	UINT32 e_version;
	UINT64 e_entry;
	UINT64 e_phoff;
	UINT64 e_shoff;
	UINT32 e_flags;
	UINT16 e_ehsize;
	UINT16 e_phentsize;
	UINT16 e_phnum;
	UINT16 e_shentsize;
} PACKED ElfHeader64;

typedef struct ElfHeader32
{
	CHAR magic[4];
	UINT8 cpu_bitsz;
	UINT8 cpu_endian;
	UINT8 elf_version;
	UINT8 e_identifier;
	UINT64 e_padding;
	UINT16 e_type;
	UINT16 e_machine;
	UINT32 e_version;
	UINT32 e_entry;
	UINT32 e_phoff;
	UINT32 e_shoff;
	UINT32 e_flags;
	UINT16 e_ehsize;
	UINT16 e_phentsize;
	UINT16 e_phnum;
	UINT16 e_shentsize;
} PACKED ElfHeader32;

typedef struct ElfProgramHeader64
{
	UINT32 p_type;
	UINT32 p_flags;
	UINT64 p_offset;
	UINT64 p_vaddr;
	UINT64 p_paddr;
	UINT64 p_filesz;
	UINT64 p_memsz;
	UINT64 p_align;
} PACKED ElfProgramHeader64;

typedef struct ElfSectionHeader64
{
	UINT32 sh_name;
	UINT32 sh_type;

	UINT64 sh_flags;

	UINT64 sh_addr;
	UINT64 sh_offset;
	UINT64 sh_size;

	UINT32 sh_link;
	UINT32 sh_info;

	UINT64 sh_addralign;
	UINT64 sh_entsize;
} PACKED ElfSectionHeader64;

typedef struct ElfProgramHeader32
{
	UINT32 p_type;
	UINT32 p_offset;
	UINT32 p_vaddr;
	UINT32 p_paddr;
	UINT32 p_filesz;
	UINT32 p_memsz;
	UINT32 p_flags;
	UINT32 p_align;
} PACKED ElfProgramHeader32;

typedef struct ElfSectionHeader32
{
	UINT32 sh_name;
	UINT32 sh_type;

	UINT64 sh_flags;

	UINT32 sh_addr;
	UINT32 sh_offset;
	UINT32 sh_size;

	UINT32 sh_link;
	UINT32 sh_info;

	UINT32 sh_addralign;
	UINT32 sh_entsize;
} PACKED ElfSectionHeader32;

#endif
