Mach was originally designed as a microkernel (everybody already knows this...), but the most
issue arises from how Mach is split up:

In version 4 of Mach, the kernel was split up into a dependent and independent part, in which
the machine-specific parts (mach4-i386, mach4-parisc, etc.) called into a "library-ified" kernel,
where some parts of the kernel may be omitted if they do not apply to that specific architecture.

In version 3 and earlier, the roles were reversed, in where the kernel calls a library-ified
set of machine-specific interfaces, and allows it to pick and choose what it should support.


The problem here is that we don't care about the underlying hardware in Feral: if it's not there,
we do software emulation to do it. Do we export these to usermode Mach applications, and
claim we're Mach 4, or do we claim we're Mach 2.5/3 and export everything?
At the end of the day, this libos exists to get gcc on Feral...

Because it's a microkernel, and we're going to pretend to be Mach until
a proper *NIX layer is built, then maybe we can port LLVM and gcc easier,
since there's a lot less to pretend to be.



I don't actually have a *real* machine running Mach (sans some weird
fork of it called XNU on some random Penryn CPU, which is probably
too distant to either version 3 or 4 of Mach, one Arch Hurd VM with the same
problem, and that's about it.)

Thus, all the processes from finding magic numbers, header IDs,
function names, etc. has to come from reading the very little documentation
I can still get my hands on, guessing based on descriptions,
or guessing based on compiling test programs on some distance descendant
(ie, Arch Hurd), and hoping it's the same as it's ancestor.

Mostly the lattermost.

This is much slower than is ideal, but one day it'd be nice to be lazy and 
instead of porting over all these *NIXen stuff, just emulate Mach, get some
BSD-like layer running on top of Mach emulation, port LLVM on that, ???,
and then self-hosting Feral!
