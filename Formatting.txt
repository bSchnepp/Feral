When the { or } is used, it should always be on a separate line, except in the case of an 'else' clause.
For example:

if (something)
{
	/* Do something... */
} else if (something else) {
	/* Do something else... */
} else {
	/*  Maybe do something else... */
}


Function declarations should be on a single line, except where the length of the line exceeds 80 characters.
When it does, the type returned, and if still necessary, the name of the function, shall be placed on preceding lines, like so:

FERALSTATUS
SomeVeryLongFunctionNameWhereItProbablyBreaksSomeOtherRuleByBeingSoLong(UINT64 arg1, UINT32 argc, STRING arg3);

FERALSTATUS SomeVeryLongFunctionNameWhereItProbablyBreaksSomeOtherRuleByBeingSoLongAndItsEvenWorseThanBefore(
	UINT64 arg1, UINT32 argc, STRING arg3
);


Where any level of ambiguity is possible (more than 3 arithmetic operations are done in a given expression), they must be surrounded
in parenthesis. It is preferred to surround non-trivial operations in parenthesis, like so:


UINT32 someVal = (1 + (5 + someVal));
UINT32 someVal2 = (someVal * 2);





Tabs should always be used over spaces:
this is to allow for flexibility in rendering source code in an editor, so that
it can fit a variety of screens, terminal emulators, etc.

For example,
{
	/* Something */
}

as opposed to
{
        /*  Something */
}



Integer division with signed numbers should be avoided: if possible, it is suggested to convert the number
to unsigned numbers and apply a sign change after the operation.
Compilers used for Feral should always round down values (truncation), such that -(7/3) should always return -2.


The use of '#pragma' compiler instructions is not allowed in the kernel.



Trigraphs should not be used at all.



C++/C99-style comments (//) should not be used in the kernel. While we aim for compatibility with C11, we would like
to get as much C89 compliance as possible, for additional portability. Feral may find use in embedded systems (for one reason or another),
where they may be only one, obscure C compiler supporting only specifically what the language specification details.



typedefs, item types, and definitions should not be overridden: for example,
if a struct is declared with a given name, the same name shall not be used to define a union elsewhere
within the same scope (ie, as a member of the same struct, or as a definition in a header).

For example, this is not allowed:

typedef struct SomeStruct
{
	struct something 
	{
		UINTN aNum;
	};
	
	union something
	{
		WSTRING hi;
		STRING hi2;
	}
}SomeStruct;

Whereas this is allowed:

typedef struct SomethingOne
{
	union content
	{
		WSTRING hello;
		UINT64 hi2;
	};
}SomethingOne;

typedef struct SomethingTwo
{
	union content
	{
		STRING hello;
		UINT64 hi2;
	};
}SomethingTwo;


The use of octal constants is discouraged.


All functions and variables must be explicitly declared: the use of implied functions shall not be used
in the kernel. For example, an implied int assignment is not allowed, nor is an implied function
where, while existing, is not explicitly declared as a function name elsewhere and prior to it's invokation,
ie, "int somefunctionFoo()", before "somefunctionFoo()" is called.

All variables must be declared with an explicit type.


All functions in the kernel must be called using the cdecl calling convention. When this is not possible,
the function in question must have a driver function to call it using the cdecl calling convention. The exception
to this is in a libOS, where compatibility with other conventions is necessary to function as intended: however,
deviations from cdecl should be documented. This is intended to make modules written is assembly language
always consistently be able to assume how a function is set up before invoking a call or jump instruction.


Bitfields should be avoided, and instead implemented as 1 shifted to a specific location in an integer.
For example,

typedef enum FooValue
{
	SOMETHING_IMPORTANT = (0 << 0),
	SOMETHING_ELSE = (1 << 1),
	SOMETHING_OTHER_ELSE = (1 << 2),
};

Or with the normal, #define (SOMETHING_OTHER_ELSE) (1 << 2). This practice is recommended, as it guarantees
the size of enum to be consistent between compilers, compiled binaries, and so on.

When an integer is used in this fashion, it must be either an enum (not recommended), or a typedefed integer
with an appropriate alias, ie,

typedef UINT64 FooValue;


When possible, the header <feral/stdtypes.h> should be included,
and it's types, such as UINT16, UINT32, UINTN, INTN, etc.
should be used, as they specify bit size and length.
When comparing between integers, an unsigned comparison
must always be made with an unsigned number, and likewise
a signed number should always be compared against a signed one.



static variables being reused across source code files should be avoided.




Code where a value may have 2 differing values after an initial arithmetic operation should be avoided where
possible.
ie,

if (a < 14)
{
	b = 10;
} else {
	b = 5;
}

This should instead be written as follows, assuming the b = 5 case is more common:

b = 5;
if (a < 14)
{
	b = 10;
}


This is part of the Zen optimization guide (page 37, note 5), and thus
must be included as part of our style guide.
