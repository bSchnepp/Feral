/*
Copyright (c) 2018, Brian Schnepp

Permission is hereby granted, free of charge, to any person or organization 
obtaining a copy of the software and accompanying documentation covered by 
this license (the "Software") to use, reproduce, display, distribute, execute, 
and transmit the Software, and to prepare derivative works of the Software, 
and to permit third-parties to whom the Software is furnished to do so, all 
subject to the following:

The copyright notices in the Software and this entire statement, including 
the above license grant, this restriction and the following disclaimer, must 
be included in all copies of the Software, in whole or in part, and all 
derivative works of the Software, unless such copies or derivative works are 
solely in the form of machine-executable object code generated by a source 
language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY 
DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.
 */

#include <stdint.h>

#include <feral/feralstatus.h>
#include <feral/stdtypes.h>
#include <feral/kern/frlos.h>

#if defined(__x86_64__)
#include <arch/x86_64/vga/vga.h>
#include <arch/x86_64/cpuio.h>
#include <arch/x86_64/cpufuncs.h>
#endif

#if 0
#if defined(__x86_64__) || defined(__i386__)
#include "feral_multiboot2.h"
#endif
#endif	//TODO

#include <feral/boot/kibootstruct.h>
#include <feral/kern/ki.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

static CHAR* cpu_vendor_msg = "CPU Vendor: ";


/* 
	Things to do in order:
	Memory management subsystems
	Simple filesystem (ext2 is enough)
	Create libc, get C++ stuff working on Waypoint
	Port LLVM/Clang
	Port LLD, YASM, and the rest of the toolchain
	Work on being self-hosting
	Create a vega10 GPU driver
	Create a desktop environment
	Create an alternative to the LiveCD tools we need currently, create a bootloader that understands (U)EFI.
	Implement Multiboot 2 support
	New filesystem focused on getting as fast read times as possible on files (eliminate file fragmentation by not allowing fragmentation?, yes, more writes, but avoids non-sequential reads.)
	Add some random hypervisor capability just for fun or something.
	Get a working Vulkan driver for the vega10 GPU (Do some magic to port AMDVLK and/or RADV or something, then just modify them?).
	Port some open source games over, see if we can get it to outperform some other OSes just by running on Feral Waypoint.
	???
 */

VOID KiSystemStartup(VOID)
{
	//TODO...
	//We need to look for every core on the system (We should expect 8, as we're expecting to run on a ZEN 1700X CPU.)
	//As such, we need to run a function called HalInitializeProcessor (for the remaining 7 cores... for 1950X support eventually, 15 remaining cores...)
	//And then call KiInitializeKernel as needed. We'll also have to use SMT when we can, and probably just assume the hardware supports SMT.

	//Of course, don't be bad, actually check if a feature is available before using it.
}

//temporary, replace soon.
DWORD internalStrLen(char* string)
{
	int len = 0;
	while (string[len])
	{
		len++;
	}
	return len;
}

// temporary, turn into clean later.
VOID InternalPrintRegister(DWORD reg, DWORD posx, DWORD posy)
{
	for (int i = 0; i < 4; i++)
	{
		CHAR charToAdd = ((CHAR)(reg >> (i * 8)) & 0xFF);
		VgaEntry(VGA_WHITE, VGA_BLACK, charToAdd, posx+i, posy);
	}
}

// ugly hack, refactor sometime later.
VOID InternalPrintCpuVendor(DWORD part1, DWORD part2, DWORD part3)
{
	DWORD len = internalStrLen(cpu_vendor_msg);
	InternalPrintRegister(part1, len+0, 1);
	InternalPrintRegister(part2, len+4, 1);
	InternalPrintRegister(part3, len+8, 1);
	VgaStringEntry(VGA_WHITE, VGA_BLACK, cpu_vendor_msg, len, 0, 1);
}

//On my laptop, we start in 40x25 for some reason. We REALLY want 80x25 because 40 looks too wide.
//EDIT: grub's doing it. We'll need to use outb and inb and all as needed to manipulate VGA. (ie, a real VGA driver.)
//EDIT: My desktop does it too. So yeah, GRUB puts us in 40x25 for some reason.
// Options are pretty much (in order of difficulty): write a VGA driver, write a vega10 gpu driver, or beg someone with a fab to teach me electronics and design a GPU.
// So, basically for now, we have the first option, and if through some miracle I happen to learn how to mess with FPGAs and get them implemented in real hardware, that too.
// Either way, getting to a vega10 driver is more or less inevitable, it just needs to happen if we want serious support for video games (the primary purpose of Waypoint!!!)
VOID kern_init(void)
{
	char* string = "Feral kernel booting...";
	VgaStringEntry(VGA_WHITE, VGA_BLACK, string, internalStrLen(string), 0, 0);
	//String entry up above isn't how I'd ideally handle this sort of stuff.

	// We'd like to have some information about the CPU before we boot further.
	// Some things like saying CPU vendor, family, brand name, etc.
	// Eventually, supporting a boot-time flag (and somehow emulating some useful CPU features
	// in-software if not available on the real thing???) would be great.
	// We'll probably use the crypto coprocessor (SHA, etc.) to our advantage with A:/Devices/Hash or something.

	/* This will represent the 4 core registers we need for CPU-specific stuff. */
	DWORD part1 = 0;
	DWORD part2 = 0;
	DWORD part3 = 0;
	DWORD part4 = 0;

	cpuid_vendor_func(&part1, &part2, &part3);
	InternalPrintCpuVendor(part1, part2, part3);	//TODO: cleanup.


	// 'part1' needs to be a reference to the chunk we want (0x8000000[2, 3, 4])
	// This number is then overridden with the appropriate value for the CPUID brand string.
	// As such, we print IMMEDIATELY, then go and replace part1 with the next bit.
	// We may need to load this into a 12-char buffer later.


	for (int i = 0; i < 3; i++)
	{
		part1 = 0x80000002 + i;
		cpuid_brand_name(&part1, &part2, &part3, &part4);
		InternalPrintRegister(part1, 0  + (16 * i), 2);
		InternalPrintRegister(part2, 4  + (16 * i), 2);
		InternalPrintRegister(part3, 8  + (16 * i), 2);
		InternalPrintRegister(part4, 12 + (16 * i), 2);
	}


	/* Below are just tests to make sure the extremely primitive VGA driver works as intended. */
	char* Stringy = "Hello, world!!!111";
	for (int k = 0; k < 33; k++)
	{
		KiPrintLine(Stringy);
	}
	for (int k = 0; k < 3; k++)
	{
		KiPrintLine(" ");
	}
	KiPrintLine("HELLO!");
	KiPrintLine("AAA");
	KiPrintLine("BBB");
	KiPrintLine("AL");
	KiPrintLine("HELLO!");
	KiPrintLine("AAA");
	KiPrintLine("BBB");
	VgaMoveCursor(25, 25);
	
}
