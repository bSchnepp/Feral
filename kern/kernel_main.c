/*
Copyright (c) 2018, 2019, 2020 Brian Schnepp

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute, execute,
and transmit the Software, and to prepare derivative works of the Software,
and to permit third-parties to whom the Software is furnished to do so, all
subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer, must
be included in all copies of the Software, in whole or in part, and all
derivative works of the Software, unless such copies or derivative works are
solely in the form of machine-executable object code generated by a source
language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY
DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
 */

#include <feral/feralstatus.h>
#include <feral/stdtypes.h>
#include <feral/kern/frlos.h>
#include <mm/mm.h>

#include <feral/kern/krnlbase.h>
#include <feral/kern/krnlfuncs.h>
#include <feral/kern/krnlprocessor.h>

#include <krnl.h>
#include <kern_ver.h>

/**
 * @file kern/kernel_main.c
 * @brief The main entry point of the kernel.
 */

VOID KiStartupMachineDependent(VOID);
VOID KiStartupProcessorMachineDependent(UINT32 Core);

/**
 * @brief The main system startup point, after firmware initialization
 * has completed.
 *
 * @details The bootloader prepares the kernel for it's initial state
 * at runtime, which should be to map the kernel at a high virtual
 * address and the state of mappings for the lower half of memory is undefined.
 * The environment block passed to the kernel contains necessary routines
 * from the hardware abstraction layer to do certain things such as
 * obtain display sizes and basic user interaction. This function never
 * returns.
 *
 * @param EnvBlock The firmware environment block that the kernel should
 * use for details about firmware memory locations, graphics primitives,
 * and some other details about the machine.
 */
VOID KiSystemStartup(KrnlEnvironmentBlock *EnvBlock)
{
	/* First off, ensure we load all the drivers,
	 * so we know what's going on. Use a couple prints to check for
	 * any regressions.
	 */
	KiUpdateFirmwareFunctions(EnvBlock->FunctionTable, EnvBlock->CharMap);

	/* Set up memory immediately so we can use the framebuffer */
	KiStartupSystem(FERAL_SUBSYSTEM_MEMORY_MANAGEMENT);
	KiPrintFmt("\nStarting Feral Kernel \"%s\" Version %01u.%01u.%01u\n",
		FERAL_VERSION_SHORT, FERAL_VERSION_MAJOR, FERAL_VERSION_MINOR,
		FERAL_VERSION_PATCH);

	/* Fmt doesn't properly take 'lu' yet, FIXME TODO... */
	KiPrintFmt("Found %lu mebibytes of free memory\n",
		EnvBlock->FunctionTable->GetMaxPhysicalAddress()
			/ (1024 * 1024));

	/* And then throw some other messages out there
	 * to prove that the framebuffer works.
	 */
	KiPrintLine("Copyright (c) 2018-2020, Brian Schnepp");
	KiPrintFmt("Booted using %s\n",
		EnvBlock->FunctionTable->GetFirmwareName());
	KiPrintFmt("%s\n", "Preparing execution environment...");
	KiStartupSystem(FERAL_SUBSYSTEM_ARCH_SPECIFIC);

	/* Formally start processor 0. */
	KiStartupProcessor(0);

	/* TODO: Get processor count and initialize the other ones. */


	/* Only load drivers *after* base system initializtion. */
	KiPrintFmt("Loading all drivers...\n");
	FERALSTATUS KiLoadAllDrivers(VOID);

	/* These are macroed away at release builds.
	 * They're eliminated at build time.
	 */
	KiDebugPrint("INIT Reached here.");

	/* Once kernel initialization is done, don't let it jump back! */
	for (;;)
	{
	}
}

/**
 * @brief Set up and start a processor based on it's number.
 *
 * @details A given microcomputer may have more than one physical processing
 * core, or if SMT is available, several times the physical cores depending
 * on the amount of logical cores available. This function allows the kernel
 * to initialize a specific core with a valid stack, and prepare other hardware
 * details about that processor based on information made available to it.
 *
 * @param ProcessorNumber The logical processor number, as a UINT32.
 *
 * @return STATUS_SUCCESS on success.
 */
FERALSTATUS KiStartupProcessor(UINT32 ProcessorNumber)
{
	/* Create a new stack for this core. */
	/* Complete the rest of the startup process... */
	KiStartupProcessorMachineDependent(ProcessorNumber);
	return STATUS_SUCCESS;
}

/* nyi */
FERALSTATUS KeBootstrapSystem(VOID)
{
	/* Bootstrap process to actually get to user mode. */
	return STATUS_SUCCESS;
}
