/*
Copyright (c) 2019, Brian Schnepp

Permission is hereby granted, free of charge, to any person or organization 
obtaining a copy of the software and accompanying documentation covered by 
this license (the "Software") to use, reproduce, display, distribute, execute, 
and transmit the Software, and to prepare derivative works of the Software, 
and to permit third-parties to whom the Software is furnished to do so, all 
subject to the following:

The copyright notices in the Software and this entire statement, including 
the above license grant, this restriction and the following disclaimer, must 
be included in all copies of the Software, in whole or in part, and all 
derivative works of the Software, unless such copies or derivative works are 
solely in the form of machine-executable object code generated by a source 
language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY 
DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.
 */


#include <feral/stdtypes.h>
#include <feral/kern/frlos.h>
#include <feral/kern/krnlfuncs.h>
#include <arch/x86_64/idt/idt.h>
#include <arch/x86_64/cpuio.h>
#include <arch/x86_64/cpufuncs.h>


#define X86_PIC_1_COMMAND (0x20)
#define X86_PIC_1_DATA (0x21)

#define X86_PIC_2_COMMAND (0xA0)
#define X86_PIC_2_DATA (0xA1)


static IDTDescriptor IDT[256];
static IDTLocation IDTPTR;

extern void x86_install_idt(IDTLocation *Pointer);
extern void x86_divide_by_zero(VOID);
extern void x86_interrupt_3(VOID);
extern void x86_interrupt_14(VOID);
extern void x86_interrupt_33(VOID);

extern VOID VgaSwapBuffers(VOID);

volatile void x86SetupIDTEntries(VOID);
void x86DisablePIC(VOID);
INTERRUPT void DivideByZero(x86InterruptFrame *Frame);
INTERRUPT void GenericHandler(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC2(x86InterruptFrame *Frame);
INTERRUPT void DoubleFaultHandler(x86InterruptFrame *Frame);
INTERRUPT void PS2KeyboardHandler(x86InterruptFrame *Frame);

INTERRUPT void GenericHandlerPIC1_IRQ0(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1_IRQ1(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1_IRQ2(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1_IRQ3(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1_IRQ4(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1_IRQ5(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1_IRQ6(x86InterruptFrame *Frame);
INTERRUPT void GenericHandlerPIC1_IRQ7(x86InterruptFrame *Frame);

void x86PICSendEOIPIC1(void);
void x86PICSendEOIPIC2(void);

void x86PICSendEOIPIC1(void)
{
	x86outb(X86_PIC_1_COMMAND, 0x20);
}

void x86PICSendEOIPIC2(void)
{
	x86outb(X86_PIC_2_COMMAND, 0x20);
	x86outb(X86_PIC_1_COMMAND, 0x20);
}

void x86DisablePIC(VOID)
{
	x86outb(X86_PIC_1_DATA, 0xFF);
	x86outb(X86_PIC_2_DATA, 0xFF);
}


INTERRUPT void GenericHandlerPIC1_IRQ0(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) (IRQ0) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC1_IRQ1(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) (IRQ1) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC1_IRQ2(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) (IRQ2) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC1_IRQ3(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) (IRQ3) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC1_IRQ4(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) (IRQ4) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC1_IRQ5(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) (IRQ5) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC1_IRQ6(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) (IRQ6) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC1_IRQ7(x86InterruptFrame *Frame)
{
	/* Ignore number 7. */
	x86PICSendEOIPIC1();
}

void x86InitializeIDT()
{
	/* Occasionally, some Zen cores *really* like reclocking themselves
	 * to 400MHz until you reboot. To err on the side of safety, assume 
	 * we'll need io_stall to put up with these chips. 
	 *
	 * (On that note, I'd like to blame laptop manufacturers for not using
	 * the CPU right... this has *never* happened on my desktops.)
	 *
	 * This is particularly the case on my 17z. So, we'll have to see if
	 * I can clean up the mess the BIOS devs did in ring 0, or if I can
	 * set the kernel up in a way to do that APIC remap trick to escalate to
	 * ring -2 access and fix it the harder way for specific devices and
	 * play with writing to pmem in certain places. Will need to do some
	 * dumping of RAM, probably see if this is even possible, and then
	 * fight all day with the BIOS to do what I want it to.
	 * 
	 * It's not a security vulnerability! It's a feature!
	 */

	/* Make the PIT happy. */
	INT32 Divisor = 11931840;
	x86outb(0x43, 0x36); /* Tell the PIT to accept it. */
	x86outb(0x40, (Divisor >> 0) & 0xFF);
	x86outb(0x40, (Divisor >> 8) & 0xFF);

	/* Initialize the PICs. 0x10 for INIT, and 0x01 for disabling stuff. */
	KiSetMemoryBytes(IDT, 0, (sizeof(IDTDescriptor)) * 256);
	x86outb(X86_PIC_1_COMMAND, (0x10 | 0x01));
	x86outb(X86_PIC_2_COMMAND, (0x10 | 0x01));
	x86_io_stall();

	/* Do the remap! */
	x86outb(X86_PIC_1_DATA, 0x20); /* First 7 interrupts */
	x86outb(X86_PIC_2_DATA, 0x28); /* Last 8 interrupts */
	x86_io_stall();

	/* Handle the cascades. */
	x86outb(X86_PIC_1_DATA, 0x04); /* First 7 interrupts */
	x86outb(X86_PIC_2_DATA, 0x02); /* Last 8 interrupts */
	x86_io_stall();

	/* Environment info... */
	x86outb(X86_PIC_1_DATA, 0x01); /* First 7 interrupts */
	x86outb(X86_PIC_2_DATA, 0x01); /* Last 8 interrupts */
	x86_io_stall();

	/* Leave this alone for now... */
	x86outb(X86_PIC_1_DATA, 0x01); /* First 7 interrupts */
	x86outb(X86_PIC_2_DATA, 0x01); /* Last 8 interrupts */
	x86_io_stall();

	x86outb(X86_PIC_1_DATA, 0xFC); /* Only allow a few IRQs. For now. */
	x86outb(X86_PIC_2_DATA, 0x80); /* Allow all the PIC 2 IRQs..? */

	for (UINTN i = 0; i < 255; ++i)
	{
		x86IDTSetGate(i, (UINT_PTR)(GenericHandler), 0x08, 0x8E);
	}
	x86IDTSetGate(0x20, (UINT_PTR)(GenericHandlerPIC1_IRQ0), 0x08, 0x8E);
	x86IDTSetGate(0x21, (UINT_PTR)(GenericHandlerPIC1_IRQ1), 0x08, 0x8E);
	x86IDTSetGate(0x22, (UINT_PTR)(GenericHandlerPIC1_IRQ2), 0x08, 0x8E);
	x86IDTSetGate(0x23, (UINT_PTR)(GenericHandlerPIC1_IRQ3), 0x08, 0x8E);
	x86IDTSetGate(0x24, (UINT_PTR)(GenericHandlerPIC1_IRQ4), 0x08, 0x8E);
	x86IDTSetGate(0x25, (UINT_PTR)(GenericHandlerPIC1_IRQ5), 0x08, 0x8E);
	x86IDTSetGate(0x26, (UINT_PTR)(GenericHandlerPIC1_IRQ6), 0x08, 0x8E);
	x86IDTSetGate(0x27, (UINT_PTR)(GenericHandlerPIC1_IRQ7), 0x08, 0x8E);
	for (UINTN i = 0x28; i < 0x30; ++i)
	{
		x86IDTSetGate(i, (UINT_PTR)(GenericHandlerPIC2), 0x08, 0x8E);
	}
	IDTPTR.Limit = ((sizeof(IDTDescriptor)) * 256) - 1;
	UINT_PTR Location = (&IDT);
	IDTPTR.Location = Location;
	x86SetupIDTEntries();

	KiPrintFmt("IDT Ready to work...\n");
	x86_install_idt(&IDTPTR);
	KiRestoreInterrupts(TRUE);
}

volatile void x86IDTSetGate(UINT8 Number, UINT_PTR Base, UINT16 Selector, UINT8 Flags)
{
	/* 0 - 255 happens to be valid, so no need for checking. */
	IDTDescriptor Descriptor = {0};

	Descriptor.Offset = (UINT16)(Base & 0xFFFF);
	Descriptor.Offset2 = (UINT16)((Base >> 16) & 0xFFFF);
	/* 
		Reserved should stay reserved. (on 32-bit x86, 
		these are different fields, but the function
		is the same: don't do anything with it.
	*/
	Descriptor.RESERVED = 0;

	/* And the important bits. */
	Descriptor.Selector = Selector;
	Descriptor.TypeAttr = Flags;

/* Handful of embedded x86s out there. May want to support one day. */
#if defined(__x86_64__)
	Descriptor.Offset3 = (UINT32)((Base >> 32) & 0xFFFFFFFF);
	/* No TSS, so set to zero. */
	Descriptor.IST = 0;
#endif
	IDT[Number] = Descriptor;
}


INTERRUPT void DivideByZero(x86InterruptFrame *Frame)
{
	KiPrintFmt("DIVIDING BY ZERO!!!\n");
}

INTERRUPT void GenericHandler(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt!\n");
}

INTERRUPT void GenericHandlerPIC1(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC1) \n");
	x86PICSendEOIPIC1();
}

INTERRUPT void GenericHandlerPIC2(x86InterruptFrame *Frame)
{
	KiPrintFmt("Unhandled Interrupt! (PIC2) \n");
	x86PICSendEOIPIC2();
}

INTERRUPT void DoubleFaultHandler(x86InterruptFrame *Frame)
{
	KiStopError(STATUS_ERROR);
}

static UINT8 ScreenTimer = 0;

INTERRUPT void PITHandler(x86InterruptFrame *Frame)
{
	/* Invoke switching of process or something. */
	if (++ScreenTimer == 16)
	{
		/* Switch banks on the framebuffer... */
		ScreenTimer = 0;
		VgaSwapBuffers();
	}
	x86PICSendEOIPIC1();
}


typedef struct PS2KeyboardContext
{
	UINT8 ShiftModifier;
	UINT8 ControlModifier;
	UINT8 AltModifier;
} PS2KeyboardContext;

static PS2KeyboardContext KeyboardContext = {0};

char ApplyShiftIfNeeded(CHAR In);

char ApplyShiftIfNeeded(CHAR In)
{
	/* There's some symbols like < and ; we have to worry about later. */
	if (In < 'A' || In > 'z')
	{
		return In;
	}

	if (KeyboardContext.ShiftModifier)
	{
		return (In & ~0x20);
	}
	else
	{
		return (In | 0x20);
	}
}



void CheckStatusCode(UINT8 In)
{
	if (In == 0xBA)
	{
		KeyboardContext.ShiftModifier = !(KeyboardContext.ShiftModifier);
	}

	if (In == 0x2A || In == 0x36)
	{
		KeyboardContext.ShiftModifier = 1;
	}
	else if (In == 0xAA || In == 0xB6)
	{
		KeyboardContext.ShiftModifier = 0;
	}
}

/* TODO: Support new keymaps... */
CHAR InternalConvertPS2KeyToASCII(CHAR In)
{
	/* TODO: convert this to a lookup table... */
	CHAR ProperLetter = '\0';
	if (In == 0x1E)
	{
		ProperLetter = 'a';
	}
	else if (In == 0x30)
	{
		ProperLetter = 'b';
	}
	else if (In == 0x2E)
	{
		ProperLetter = 'c';
	}
	else if (In == 0x20)
	{
		ProperLetter = 'd';
	}
	else if (In == 0x12)
	{
		ProperLetter = 'e';
	}
	else if (In == 0x21)
	{
		ProperLetter = 'f';
	}
	else if (In == 0x22)
	{
		ProperLetter = 'g';
	}
	else if (In == 0x23)
	{
		ProperLetter = 'h';
	}
	else if (In == 0x17)
	{
		ProperLetter = 'i';
	}
	else if (In == 0x24)
	{
		ProperLetter = 'j';
	}
	else if (In == 0x25)
	{
		ProperLetter = 'k';
	}
	else if (In == 0x26)
	{
		ProperLetter = 'l';
	}
	else if (In == 0x32)
	{
		ProperLetter = 'm';
	}
	else if (In == 0x31)
	{
		ProperLetter = 'n';
	}
	else if (In == 0x18)
	{
		ProperLetter = 'o';
	}
	else if (In == 0x19)
	{
		ProperLetter = 'p';
	}
	else if (In == 0x10)
	{
		ProperLetter = 'q';
	}
	else if (In == 0x13)
	{
		ProperLetter = 'r';
	}
	else if (In == 0x1F)
	{
		ProperLetter = 's';
	}
	else if (In == 0x14)
	{
		ProperLetter = 't';
	}
	else if (In == 0x16)
	{
		ProperLetter = 'u';
	}
	else if (In == 0x2F)
	{
		ProperLetter = 'v';
	}
	else if (In == 0x11)
	{
		ProperLetter = 'w';
	}
	else if (In == 0x2D)
	{
		ProperLetter = 'x';
	}
	else if (In == 0x15)
	{
		ProperLetter = 'y';
	}
	else if (In == 0x2C)
	{
		ProperLetter = 'z';
	}
	else if (In == 0x1C || In == 0x5A)
	{
		ProperLetter = '\n';
	}
	else if (In == 0x39 || In == 0x29)
	{
		ProperLetter = ' ';
	}
	return ApplyShiftIfNeeded(ProperLetter);
}


/* We'll need to pull this out into a proper driver later. */
INTERRUPT void PS2KeyboardHandler(x86InterruptFrame *Frame)
{
	UINT8 Status;
	CHAR Keycode;
	Keycode = x86inb(0x60); /* Data is 0x60. */
	CheckStatusCode(Keycode);
	CHAR Letter = InternalConvertPS2KeyToASCII(Keycode);
	CHAR Buffer[2] = {0};
	Buffer[0] = Letter;
	if (Letter)
	{
		KiPrintFmt(Buffer);
	}
	x86PICSendEOIPIC1();
}


volatile void x86SetupIDTEntries()
{
	/* 0x08 is for kernel code segment offset */
	/* 0x8E is for interrupt gate. */

	/* On number 14 (page fault), install custom handler. */
	x86IDTSetGate(0x00, (UINT_PTR)(DivideByZero), 0x08, 0x8E);
	x86IDTSetGate(0x08, (UINT_PTR)(DoubleFaultHandler), 0x08, 0x8E);
	x86IDTSetGate(0x14, (UINT_PTR)(DoubleFaultHandler), 0x08, 0x8E);
	x86IDTSetGate(0x20, (UINT_PTR)(PITHandler), 0x08, 0x8E);
	x86IDTSetGate(0x21, (UINT_PTR)(PS2KeyboardHandler), 0x08, 0x8E);
	x86IDTSetGate(0x2C, (UINT_PTR)(PS2KeyboardHandler), 0x08, 0x8E);
}

VOID KiRestoreInterrupts(BOOLEAN value)
{
	if (value)
	{
		__asm__ __volatile__("sti");
	}
	else
	{
		__asm__ __volatile__("cli");
	}
}