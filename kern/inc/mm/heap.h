/*
Copyright (c) 2019, Brian Schnepp

Permission is hereby granted, free of charge, to any person or organization 
obtaining a copy of the software and accompanying documentation covered by 
this license (the "Software") to use, reproduce, display, distribute, execute, 
and transmit the Software, and to prepare derivative works of the Software, 
and to permit third-parties to whom the Software is furnished to do so, all 
subject to the following:

The copyright notices in the Software and this entire statement, including 
the above license grant, this restriction and the following disclaimer, must 
be included in all copies of the Software, in whole or in part, and all 
derivative works of the Software, unless such copies or derivative works are 
solely in the form of machine-executable object code generated by a source 
language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY 
DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE.
 */

#ifndef _FERAL_HEAP_H_
#define _FERAL_HEAP_H_

#define ALLOC_BLOCK_SIZE (128)


/* 
	NOTE: This allocator is *horrible*, but is designed to
	be tolerable on SMP systems. (our favorite Red CPUs come with
	absurd numbers of cores, ranging from 2 on the low end to something
	like 64 on HEDT/servers... with SMT (128 harts), and then dual socket,
	so 256 harts. That's a lot to manage, and scale well.
	
	Some bad things are:
		- Jump to worst case pretty commonly.
		- Doesn't *actually* care about threads right now
	
	For that reason, ThreadIndex is UINT64, because one day someone is
	going to build a supercomputer with 2^64-1 harts or
	something just absurdly large. Allocator needs to scale well.)
	That should NOT be conflated with user mode threads. "Threads"
	in this context refers to SMT hardware threads.
	
	Important ideas here are:
		- Each Arena is unique per thread.
		- Having multiple arenas means there's less lock fighting.
			(... until an Arena is full, at least.)
		- Static allocation size of 128. No realloc (yet), but
			that shouldn't be too crazy to do.
		- Free should be easy!
	
	Dynamic memory is pretty important--I don't want to do silly things
	with the IDT and GDT with some static buffer from the BSS.
 */


/* 
	Adjacent nodes always point to adjacent memory areas. Flaw in this
	allocator for now, but that can be fixed.
 */ 
typedef struct Node
{
	BOOL Used;	/* Already in use? */
	BOOL Last;	/* Is this the last node? */
	VOID *Area;	/* What area is it in? */
	UINT64 NodeIndex;	/* In the Arena, what number is this? */
	
	struct Node *Previous;
	struct Node *Next;
	
	/* How much space does it take up, as multiples of ALLOC_BLOCK_SIZE? */
	UINT64 ChunkIncrement;
}Node;


/* 
	A thread holds an arena where memory could
	be allocated or freed from.
 */
typedef struct Arena
{
	UINT64 Size;		/* How much space is there? */
	UINT64 ThreadIndex;	/* What hart owns this arena? */
	Node *Root;		/* The start of the list. O(n) removal. */
	Node *NextToAllocate;	/* O(1) indexing for malloc performance */
}Arena;


#endif
