/*
Copyright (c) 2020 Brian Schnepp

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute, execute,
and transmit the Software, and to prepare derivative works of the Software,
and to permit third-parties to whom the Software is furnished to do so, all
subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer, must
be included in all copies of the Software, in whole or in part, and all
derivative works of the Software, unless such copies or derivative works are
solely in the form of machine-executable object code generated by a source
language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY
DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
 */

/**
 * @file entry/mb2entry.c
 * @internal
 */

#include <feral/stdtypes.h>
#include <stdint.h>

#if defined(__x86_64__)
#include <arch/x86_64/cpuio.h>
#include <arch/x86_64/cpuinfo.h>
#include <arch/x86_64/cpufuncs.h>
#endif

#include "charmap_default.inl"

#include <feral/feralstatus.h>
#include <feral/stdtypes.h>
#include <feral/kern/frlos.h>
#include <mm/mm.h>

#include <feral/kern/krnlfuncs.h>
#include <feral/kern/krnlbase.h>

#include <krnl.h>
#include <kern_ver.h>


/* hack: include the serial driver in a brute forcey way. */
#include <drivers/serial/serial.h>

/* The initial memory map is done at the end of the kernel memory. */
extern UINTN kern_end;
/* FIXME: There's a buffer overrun somewhere. */
static UINT_PTR kernel_end = &(kern_end) + 4096;

/* hack for now */
static UINT64 MemoryRangeCount;

/*
	 We'll need to implement a proper driver for VGA later.
	 For now, we have something to throw text at and not quickly run out
	 of space.
 */

#ifndef FERAL_BUILD_STANDALONE_UEFI_
#include "multiboot/multiboot2.h"
#include <drivers/proc/elf/elf.h>
#include <arch/x86_64/vga/vga.h>

static CHAR *cpu_vendor_msg = "CPU Vendor: ";



/**
 * @internal
 * @brief Reads a register as a series of ASCII characters, and prints
 * to the VGA console.
 */
VOID InternalPrintRegister(UINT32 reg)
{
	for (int i = 0; i < 4; i++)
	{
		CHAR charToAdd = ((CHAR)(reg >> (i * 8)) & 0xFF);
		VgaAutoEntry(VGA_GREEN, VGA_BLACK, charToAdd);
	}
}

/**
 * @internal
 * @brief Reads the results of the cpuid function for the CPU vendor,
 * and writes them to the VGA console.
 */
VOID InternalPrintCpuVendor(UINT32 part1, UINT32 part2, UINT32 part3)
{
	VgaAutoPrint(VGA_GREEN, VGA_BLACK, cpu_vendor_msg);
	InternalPrintRegister(part1);
	InternalPrintRegister(part2);
	InternalPrintRegister(part3);
	VgaAutoPrintln(VGA_WHITE, VGA_BLACK, "");
}

static KrnlFirmwareFunctions FirmwareFuncs = {0};
static KrnlCharMap CharMap = {0};
static KrnlEnvironmentBlock EnvBlock = {0};
static KrnlPhysicalDisplay Display = {0};
static SystemBootInfo BootInfo = {0};

static STRING GetBiosFirmwareClaim();
static VOID InternalVgaPrintln(STRING Str, UINT64 Len);
static VOID InternalVgaBackspace();

static STRING GetBiosFirmwareClaim()
{
	return "PC Compatible BIOS (Multiboot 2)";
}

static UINT_PTR MaxAddress = 0x00;
static UINT_PTR(InternalGetMaxPhysicalAddressFunc)(VOID)
{
	return MaxAddress;
}
static VOID InternalVgaPrintln(STRING Str, UINT64 Len)
{
	VgaPrintln(VGA_WHITE, VGA_BLACK, Str, Len);
}

static VOID InternalVgaBackspace()
{
	UINT16 X = 0;
	UINT16 Y = 0;
	VgaGetCurrentPosition(&X, &Y);

	UINT16 Width = 0;
	UINT16 Height = 0;
	VgaGetFramebufferDimensions(&Width, &Height);

	if (X == 0)
	{
		return;
	}
	--X;

	VgaMoveCursor(X, Y);
	VgaPutChar(' ');
	VgaMoveCursor(X, Y);
}


static VOID InternalPutChar(CHAR C)
{
	VgaPutChar(C);
}

VOID HandleMemory(multiboot_tag_mmap *MemoryMap)
{
	UINT64 *MemRangeHeader = (UINT64 *)kernel_end;
	BootMemoryRange *MemRange = (BootMemoryRange *)(MemRangeHeader + 1);

	multiboot_mmap_entry CurrentEntry = {0};

	UINT64 Index = 0;
	UINT64 AreasWritten = 0;
	UINT64 MaxIndex = (MemoryMap->size) / (MemoryMap->entry_size);

	/* We list all the memory there as either free or hardware reserved. */
	MemoryRangeCount = MaxIndex;
	MemRangeHeader[0] = MemoryRangeCount;

	/* Go through all the entries and try to see what type
	 * it is. */
	for (Index = 0; Index < MaxIndex; ++Index)
	{
		CurrentEntry = MemoryMap->entries[Index];
		/* Check the Type first. */
		switch (CurrentEntry.type)
		{
			case E820_MEMORY_TYPE_FREE:
			{
				MemRange[Index].Usage
					= MM_STRUCTURE_TYPE_FREE_AREA_RANGE;
				break;
			}

			case E820_MEMORY_TYPE_RESERVED:
			case E820_MEMORY_TYPE_ACPI:
			case E820_MEMORY_TYPE_NVS:
			{
				MemRange[Index].Usage
					= MM_STRUCTURE_TYPE_RESERVED_AREA_RANGE;
				break;
			}

			default:
			{
				MemRange[Index].Usage
					= MM_STRUCTURE_TYPE_OTHER_AREA_RANGE;
			}
		}
		MemRange[Index].Start = (UINT_PTR)CurrentEntry.addr;
		MemRange[Index].End = MemRange[Index].Start + CurrentEntry.len;

		if (MemRange[Index].End > MaxAddress)
		{
			MaxAddress = MemRange[Index].End;
		}
	}

	BootInfo.NumMemoryRanges = MemoryRangeCount;
	BootInfo.MemoryRanges = MemRange;
}

/* FIXME: formally write a header for this function. */
UINT_PTR get_initial_p4_table();

VOID kern_init(UINT32 MBINFO)
{
	STRING CommandLine = "";
	STRING BootloaderName = "Unknown";

	VOID *Framebuffer;
	UINT16 FramebufferBPP;
	UINT32 FramebufferWidth;
	UINT32 FramebufferHeight;
	BOOL FramebufferTextOnly;

	/*
	 * This is absolutely terrible code that needs to happen
	 * in order to make multiboot work right.
	 *
	 * First, force cast the argument to multiboot info one entry past where
	 * the bootloader told us to go.
	 *
	 * Then, some info needs to get queried from it, like each of it's tags.
	 * To check the tags, the real pointer magic begins by taking
	 * an offset by adding the size of the items which are in the way
	 * to the base pointer, force casing this, and looping until the
	 * end tag is reached.
	 *
	 * Each of these tags is then processed based on the ID of it.
	 */
	uint64_t MaxMem = 0;
	for (multiboot_tag *MultibootInfo
		= (multiboot_tag *)((UINT_PTR)(MBINFO + 8));
		MultibootInfo->type != MULTIBOOT_TAG_TYPE_END;
		MultibootInfo
		= (multiboot_tag *)((UINT8 *)(MultibootInfo)
				    + ((MultibootInfo->size + 7) & ~0x07)))
	{
		UINT16 Type = MultibootInfo->type;
		if (Type == MULTIBOOT_TAG_TYPE_CMD_LINE)
		{
			multiboot_tag_string *mb_as_string
				= (multiboot_tag_string *)(MultibootInfo);
			STRING str = mb_as_string->string;
			UINT64 len = 0;
			if (KiGetStringLength(str, &len) == STATUS_SUCCESS)
			{
				if (len != 0)
				{
					CommandLine = str;
				}
			}
		}
		else if (Type == MULTIBOOT_TAG_TYPE_BOOT_LOADER)
		{
			multiboot_tag_string *mb_as_string
				= (multiboot_tag_string *)(MultibootInfo);
			STRING str = mb_as_string->string;
			UINT64 len = 0;
			if (KiGetStringLength(str, &len) == STATUS_SUCCESS)
			{
				if (len != 0)
				{
					BootloaderName = str;
				}
			}
		}
		else if (Type == MULTIBOOT_TAG_TYPE_MEM_MAP)
		{

			/* Memory map detected... MB2's kludgy mess here makes
			 * this a little painful, but we'll go through this
			 * step-by-step.*/
			multiboot_tag_mmap *mb_as_mmap_items
				= (multiboot_tag_mmap *)(MultibootInfo);
			HandleMemory(mb_as_mmap_items);
		}
		else if (Type == MULTIBOOT_TAG_TYPE_FRAME_BUFFER)
		{
			multiboot_tag_framebuffer_common *mb_as_fb
				= (multiboot_tag_framebuffer_common
						*)(MultibootInfo);

			Framebuffer = mb_as_fb->framebuffer_addr;
			FramebufferBPP = mb_as_fb->framebuffer_bpp;
			FramebufferHeight = mb_as_fb->framebuffer_height;
			FramebufferWidth = mb_as_fb->framebuffer_width;
			FramebufferTextOnly
				= (mb_as_fb->type
					== MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT);

			BootInfo.NumDisplays = 1;
			BootInfo.FramebufferPAddrs = &(Framebuffer);
		}
	}

	UINT8 misc = VgaPrepareEnvironment(Framebuffer, FramebufferBPP,
		FramebufferWidth, FramebufferHeight, FramebufferTextOnly);
	KiBlankVgaScreen(FramebufferHeight, FramebufferWidth, VGA_BLACK);
	VgaAutoPrintln(
		VGA_WHITE, VGA_BLACK, "Starting initial kernel setup...");

	CHAR BufBeginAddr[17];
	CHAR BufEndAddr[17];
	internalItoaBaseChange(FramebufferWidth, BufBeginAddr, 10);
	internalItoaBaseChange(FramebufferHeight, BufEndAddr, 10);
	VgaAutoPrint(VGA_WHITE, VGA_BLACK, "VGA resolution is : ");
	VgaAutoPrint(VGA_GREEN, VGA_BLACK, BufBeginAddr);
	VgaAutoPrint(VGA_WHITE, VGA_BLACK, "x");
	VgaAutoPrintln(VGA_RED, VGA_BLACK, BufEndAddr);

	VgaAutoPrint(VGA_LIGHT_GREY, VGA_BLACK, "Found bootloader: ");
	VgaAutoPrintln(VGA_GREEN, VGA_BLACK, BootloaderName);

	VgaAutoPrint(VGA_LIGHT_GREY, VGA_BLACK, "Found command line: ");
	VgaAutoPrintln(VGA_GREEN, VGA_BLACK, CommandLine);

	/* This will represent the 4 core registers we need for CPUID stuff. */
	UINT32 part1 = 0;
	UINT32 part2 = 0;
	UINT32 part3 = 0;
	UINT32 part4 = 0;

	/* Some inline asm magic is used to get the CPU vendor.
	 * (ie, "KVM KVM KVM"). Thus, we use 3 dwords to pretend to
	 * be some scratch registers and then reinterpret it as a 12-byte
	 * string.
	 */
	cpuid_vendor_func(&part1, &part2, &part3);
	InternalPrintCpuVendor(part1, part2, part3);

	/* To get the reported name of the CPU,
	 * we'll need 48 bytes. On the x86, this is done
	 * by calling cpuid with the command (0x80000002 + i),
	 * where i is the segment of 16 bytes to get. We then do
	 * the same thing as with the CPU vendor thing, and reinterpret
	 * the 4 fake scratch registers as a string of 16 bytes, and then
	 * do this until all 48 characters are printed.
	 */
	UINT_PTR CpuNameCommand = 0x80000002;
	for (UINT_PTR Index = 0; Index < 3; ++Index)
	{
		part1 = CpuNameCommand + Index;
		cpuid_brand_name(&part1, &part2, &part3, &part4);
		InternalPrintRegister(part1);
		InternalPrintRegister(part2);
		InternalPrintRegister(part3);
		InternalPrintRegister(part4);
	}
	/* When we're done with CPUID, insert a newline. */
	VgaAutoPrintln(VGA_WHITE, VGA_BLACK, "");

	UINT32 familyStuff = cpuid_family_number();
	UINT32 actualFamily = (familyStuff >> 8) & 15;
	UINT32 extendedModel = (familyStuff >> 16) & (0xF);
	UINT32 baseModel = (familyStuff >> 4) & (0xF);
	UINT32 actualModel = baseModel + (extendedModel << 4);

	if (actualFamily == 0x6 || actualFamily == 0xF)
	{
		/* Family 15 wants us to report the family number as such. */
		if (actualFamily == 15)
		{
			actualFamily += (familyStuff >> 20) & 0x0FFFFFFF;
		}
		/* In both cases, we also need to append some more info from
		 * cpuid. */
		actualFamily += ((familyStuff >> 16) & 0x4);
	}


	if ((actualFamily != CPU_x86_64_FAMILY_ZEN))
	{
		/* At the moment, I am only testing on Zen hardware.
		 * anything else is unsupported (but will probably work
		 * just fine.)
		 */
		VgaAutoPrintln(VGA_RED, VGA_BLACK, "Unsupported CPU");
	}

	/* We'll want the cursor to always follow us! */
	VgaSetCursorEnabled(TRUE);
	VgaTraceCharacters(TRUE);
	VgaMoveCursor(0, 24);

	/* To generalize the kernel's boot process, we should
	 * define some functions in a sort of "interface" to the rest of
	 * the kernel now that we're about to leave the bootloader-specific
	 * block.
	 *
	 * When that happens, we'll of course want a way to put things on
	 * the screen, so let the rest of the kernel know how to do that, along
	 * with some other things.
	 */
	FirmwareFuncs.PutChar = InternalPutChar;
	FirmwareFuncs.Println = InternalVgaPrintln;
	FirmwareFuncs.GetFirmwareName = GetBiosFirmwareClaim;
	FirmwareFuncs.Backspace = InternalVgaBackspace;
	FirmwareFuncs.GetMaxPhysicalAddress = InternalGetMaxPhysicalAddressFunc;

	EnvBlock.FunctionTable = &FirmwareFuncs;
	EnvBlock.CharMap = &CharMap;
	EnvBlock.Displays = NULLPTR;
	EnvBlock.BootInfo = &BootInfo;
	/* Kernel initialization is done, move on to actual tasks. */
	KiSystemStartup(&EnvBlock);
}

#endif
